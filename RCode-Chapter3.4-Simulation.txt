#This file contains all the R code for tables and figures in Section 3.4: Simulation Study 


# !!! IMPORTANT REMINDER !!! 
# !!! IMPORTANT REMINDER !!! 
# !!! IMPORTANT REMINDER !!! 
#However, since time series are randomly generated, the results will differ each time the code is run and cant exactly replicate the data in the report.



# Install and load required package
install.packages("depmixS4")
library(depmixS4) 

# -------------------------------
# Parameter setup for simulation
# -------------------------------
nst   <- 3
pi0   <- c(0.2, 0.5, 0.3)
A     <- matrix(c(
  0.8, 0.15, 0.05,
  0.10, 0.80, 0.10,
  0.05, 0.25, 0.70
), byrow=TRUE, nrow=3)
mu    <- c(0.001, -0.0002, -0.002)
sigma <- c(0.005, 0.01, 0.03)
T     <- 1000

# -------------------------------
# HMM simulation function
# -------------------------------
simulate_hmm <- function(T, pi0, A, mu, sigma) {
  states <- numeric(T)
  y      <- numeric(T)
  states[1] <- sample(1:nst, 1, prob=pi0)
  y[1]      <- rnorm(1, mu[states[1]], sigma[states[1]])
  for (t in 2:T) {
    states[t] <- sample(1:nst, 1, prob=A[states[t-1], ])
    y[t]      <- rnorm(1, mu[states[t]], sigma[states[t]])
  }
  list(y = y, states = states)
}

# -------------------------------
# Simulate Nrep series
# -------------------------------
Nrep  <- 100
sims  <- replicate(Nrep, simulate_hmm(T, pi0, A, mu, sigma), simplify=FALSE)

# -------------------------------
# Fit a single sequence using depmixS4
# -------------------------------
fit_one <- function(y) {
  mod <- depmix(y ~ 1,
                data    = data.frame(y = y),
                nstates = nst,
                family  = gaussian(),
                instart = rep(1/nst, nst),
                trstart = matrix(1/nst, nst, nst))
  fit(mod, verbose = FALSE)
}

# -------------------------------
# Fit all sequences
# -------------------------------
fits <- lapply(sims, function(s) fit_one(s$y))

# -------------------------------
# Extract estimated parameter vector from each fitted model
# -------------------------------
extract_pars <- function(fit) {
  getpars(fit)
}
est_pars <- t(sapply(fits, extract_pars))

# -------------------------------
# Define parameter index ranges
# -------------------------------
P        <- ncol(est_pars)
idx_pi   <-        1:nst
idx_A    <- (nst+1):(nst + nst^2)
idx_mu   <- (nst + nst^2 + 1):(nst + nst^2 + nst)
idx_sig  <- (nst + nst^2 + nst + 1):(nst + nst^2 + 2*nst)

# -------------------------------
# Slice parameter matrices
# -------------------------------
pi_hat     <- est_pars[, idx_pi]
A_hat      <- est_pars[, idx_A]
mu_hat     <- est_pars[, idx_mu]
sigma_hat  <- est_pars[, idx_sig]
A_true_vec <- as.vector(t(A))  # Flatten A in row-major order

# -------------------------------
# Compute bias and standard deviation
# -------------------------------
bias_pi    <- colMeans(pi_hat)    - pi0
sd_pi      <- apply(pi_hat,    2, sd)

bias_A     <- colMeans(A_hat)     - A_true_vec
sd_A       <- apply(A_hat,     2, sd)

bias_mu    <- colMeans(mu_hat)    - mu
sd_mu      <- apply(mu_hat,    2, sd)

bias_sigma <- colMeans(sigma_hat) - sigma
sd_sigma   <- apply(sigma_hat, 2, sd)

# -------------------------------
# Assemble results into data.frames
# -------------------------------
df_pi <- data.frame(
  state = 1:nst,
  bias  = bias_pi,
  sd    = sd_pi
)

df_A <- data.frame(
  from = rep(1:nst, each = nst),
  to   = rep(1:nst, times = nst),
  bias = bias_A,
  sd   = sd_A
)

df_mu <- data.frame(
  state = 1:nst,
  bias  = bias_mu,
  sd    = sd_mu
)

df_sigma <- data.frame(
  state = 1:nst,
  bias  = bias_sigma,
  sd    = sd_sigma
)

# -------------------------------
# Print results
# -------------------------------
print("Estimated biases and SDs for initial probabilities (pi):")
print(df_pi)

print("Estimated biases and SDs for transition matrix (A):")
print(df_A)

print("Estimated biases and SDs for means (mu):")
print(df_mu)

print("Estimated biases and SDs for standard deviations (sigma):")
print(df_sigma)
